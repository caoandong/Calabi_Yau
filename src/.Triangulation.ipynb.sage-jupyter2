{"output":{"0":{"text":"(1, 0, 0)\nreset starting point:  0.867792114606 0.911752932277 0.45554879871\nsolution:  [ 1.50000114  1.4999978   1.00000027]\nguessed vol:  0.5925925925839692\nDone.\n('vol:', 0.5925925925839692, '; sol:', [1.5000011404230877, 1.4999977968369254, 1.0000002656749278])\n\n(1, 1, 0)\nreset starting point:  0.699611038725 0.746124233374 0.480540812785\nsolution:  [ 1.50002675  1.5000362   1.49998898]\nguessed vol:  0.5925925929914229\nDone.\n('vol:', 0.5925925929914229, '; sol:', [1.5000267523925717, 1.5000361982110724, 1.4999889790500398])\n\n(1, 1, 1)\nreset starting point:  0.328846304563 0.152112459992 0.224381209018\nsolution:  [ 1.50000496  1.49999872  2.4999978 ]\nguessed vol:  0.592592592627625\nDone.\n('vol:', 0.592592592627625, '; sol:', [1.5000049595595233, 1.499998721948516, 2.4999978015608537])\n\n","name":"stdout"},"1":{"data":{"text/plain":"[[[1, 0, 0],\n  0.5925925925839692,\n  [1.5000011404230877, 1.4999977968369254, 1.0000002656749278],\n  [[[1, 0, 0], [0, 0, 0], [0, 0, 1], [1, 1, 0]],\n   [[0, 1, 0], [0, 0, 0], [0, 0, 1], [1, 1, 0]]],\n  1/((b1 - b2)*b1*(b2 + b3 - 4)*b3) - 1/((b1 - b2)*(b1 + b3 - 4)*b2*b3),\n  [array([[[1, 0, 0, 1],\n           [0, 0, 0, 1],\n           [0, 0, 1, 1],\n           [1, 1, 0, 1]]]), array([[[0, 1, 0, 1],\n           [0, 0, 0, 1],\n           [0, 0, 1, 1],\n           [1, 1, 0, 1]]])],\n  [array([[[ 0.,  1.,  0.,  0.],\n           [ 1., -1., -0., -0.],\n           [-1.,  0., -1.,  1.],\n           [-0., -0.,  1., -0.]]]), array([[[ 1., -0., -0., -0.],\n           [-1.,  1.,  0.,  0.],\n           [-0., -1., -1.,  1.],\n           [ 0.,  0.,  1.,  0.]]])]],\n [[1, 1, 0],\n  0.5925925929914229,\n  [1.5000267523925717, 1.5000361982110724, 1.4999889790500398],\n  [[[1, 0, 0], [0, 0, 0], [0, 0, 1], [1, 1, 0]],\n   [[0, 1, 1], [0, 0, 0], [0, 0, 1], [1, 1, 0]]],\n  1/((b1 - b2 + b3)*(b1 - b2)*(b1 + b3 - 4)*b1) - 1/((b1 - b2)*(b1 + b3 - 4)*b2*b3),\n  [array([[[1, 0, 0, 1],\n           [0, 0, 0, 1],\n           [0, 0, 1, 1],\n           [1, 1, 0, 1]]]), array([[[0, 1, 1, 1],\n           [0, 0, 0, 1],\n           [0, 0, 1, 1],\n           [1, 1, 0, 1]]])],\n  [array([[[ 0.,  1.,  0.,  0.],\n           [ 1., -1., -0., -0.],\n           [-1.,  0., -1.,  1.],\n           [-0., -0.,  1., -0.]]]), array([[[ 1., -0., -0., -0.],\n           [-1.,  1.,  0.,  0.],\n           [-1., -0., -1.,  1.],\n           [ 1., -1.,  1.,  0.]]])]],\n [[1, 1, 1],\n  0.592592592627625,\n  [1.5000049595595233, 1.499998721948516, 2.4999978015608537],\n  [[[1, 0, 0], [0, 0, 0], [0, 0, 1], [1, 1, 1]],\n   [[1, 1, 1], [0, 0, 0], [0, 0, 1], [0, 1, 1]]],\n  1/((b1 - b2 + b3 - 4)*(b1 - b2)*(b2 - b3)*b2) - 1/((b1 - b2)*b1*(b2 - b3)*(b3 - 4)),\n  [array([[[1, 0, 0, 1],\n           [0, 0, 0, 1],\n           [0, 0, 1, 1],\n           [1, 1, 1, 1]]]), array([[[1, 1, 1, 1],\n           [0, 0, 0, 1],\n           [0, 0, 1, 1],\n           [0, 1, 1, 1]]])],\n  [array([[[ 0.,  1.,  0.,  0.],\n           [ 1., -1., -0., -0.],\n           [-1.,  1., -1.,  1.],\n           [-0., -1.,  1., -0.]]]), array([[[-1.,  1.,  0.,  0.],\n           [ 1., -0., -0., -0.],\n           [ 0.,  0., -1.,  1.],\n           [-0., -1.,  1., -0.]]])]]]"},"exec_count":5}},"exec_count":5,"start":1546883526551,"input":"generate_vol(2)","state":"done","pos":5,"cell_type":"code","type":"cell","end":1546883526755,"id":"6d40ca","kernel":"sagemath"}
{"output":{"0":{"text":"Okay.\n","name":"stdout"}},"exec_count":3,"start":1546883512190,"input":"def lift_prism(h1, h2, h3):\n    # h1 >= h2 >= h3\n    \n    triang = []\n    power = []\n    if h1 == h2 == h3:\n        series = 0\n        prism = []\n        # h1 = h2 = h3\n        for h in range(h1):\n            # 0 <= h < h1\n            prism_1 = [[[1,0,0],[0,0,h],[0,0,h+1],[1,1,h3]]]\n            prism_2 = [[[1,1,h3],[0,0,h],[0,0,h+1],[0,1,h2]]]\n            prism += prism_1 + prism_2\n            \n            series_1, triang_1, power_1 = Hilb(prism_1)\n            series_2, triang_2, power_2 = Hilb(prism_2)\n            series += series_1 + series_2\n            triang.append(triang_1)\n            triang.append(triang_2)\n            power.append(power_1)\n            power.append(power_2)\n        return prism, series, triang, power\n            \n    if h2 > h3:\n        # h1 >= h2 > h3\n        assert((h1 >= h2) and (h2 > h3))\n        series = 0\n        prism = []\n        for h in range(h3):\n            # 0 <= h < h3\n            prism_1 = [[[1,0,0],[0,0,h],[0,0,h+1],[1,1,h3]]]\n            prism_2 = [[[0,1,h2],[0,0,h],[0,0,h+1],[1,1,h3]]]\n            prism += prism_1 + prism_2\n            \n            series_1, triang_1, power_1 = Hilb(prism_1)\n            series_2, triang_2, power_2 = Hilb(prism_2)\n            series += series_1 + series_2\n            triang.append(triang_1)\n            triang.append(triang_2)\n            power.append(power_1)\n            power.append(power_2)\n\n        for h in range(h3,h2):\n            # h3 <= h < h2\n            prism_1 = [[[1,0,0],[0,0,h],[0,0,h+1],[1,1,h3]]]\n            prism_2 = [[[0,1,h2],[0,0,h],[0,0,h+1],[1,1,h3]]]\n            prism += prism_1 + prism_2\n            \n            series_1, triang_1, power_1 = Hilb(prism_1)\n            series_2, triang_2, power_2 = Hilb(prism_2)\n            series += series_1 + series_2\n            triang.append(triang_1)\n            triang.append(triang_2)\n            power.append(power_1)\n            power.append(power_2)\n\n        if h1 > h2:\n            # h1 > h2 > h3\n            assert(h1 > h2 and h2 > h3)\n            for h in range(h2,h1):\n                # h2 <= h < h1\n                prism_1 = [[[1,0,0],[0,0,h],[0,0,h+1],[1,1,h3]]]\n                prism_2 = [[[0,1,h2],[0,0,h],[0,0,h+1],[1,1,h3]]]\n                prism += prism_1 + prism_2\n                \n                series_1, triang_1, power_1 = Hilb(prism_1)\n                series_2, triang_2, power_2 = Hilb(prism_2)\n                series += series_1 + series_2\n                triang.append(triang_1)\n                triang.append(triang_2)\n                power.append(power_1)\n                power.append(power_2)\n        return prism, series, triang, power\n        \n    elif h2 < h3:\n        series = 0\n        prism = []\n        if h1 > h3:\n            # h1 > h3 > h2\n            assert(h1 > h3 and h3 > h2)\n            for h in range(h2):\n                # 0 <= h < h2\n                prism_1 = [[[1,0,0],[0,0,h],[0,0,h+1],[0,1,h2]]]\n                prism += prism_1\n                \n                series_1, triang_1, power_1 = Hilb(prism_1)\n                series += series_1\n                triang.append(triang_1)\n                power.append(power_1)\n            \n            # Middle prism:\n            prism_1 = [[[1,0,0],[0,1,h2],[0,0,h2],[1,1,h3]]]\n            prism += prism_1\n            \n            series_1, triang_1, power_1 = Hilb(prism_1)\n            series += series_1\n            triang.append(triang_1)\n            power.append(power_1)\n            \n            for h in range(h2,h3):\n                # h2 <= h < h3\n                prism_1 = [[[1,0,0],[0,0,h],[0,0,h+1],[1,1,h3]]]\n                prism_2 = [[[0,1,h2],[0,0,h],[0,0,h+1],[1,1,h3]]]\n                prism += prism_1 + prism_2\n                \n                series_1, triang_1, power_1 = Hilb(prism_1)\n                series_2, triang_2, power_2 = Hilb(prism_2)\n                series += series_1 + series_2\n                triang.append(triang_1)\n                triang.append(triang_2)\n                power.append(power_1)\n                power.append(power_2)\n            return prism, series, triang, power\n                \n        else:\n            # h1 = h3 > h2\n            assert(h1 == h3 and h3 > h2)\n            for h in range(h2):\n                # 0 <= h < h2\n                prism_1 = [[[1,0,0],[0,0,h],[0,0,h+1],[0,1,h2]]]\n                prism += prism_1\n                \n                series_1, triang_1, power_1 = Hilb(prism_1)\n                series += series_1\n                triang.append(triang_1)\n                power.append(power_1)\n                \n            # Middle prism:\n            prism_1 = [[[1,0,0],[0,1,h2],[0,0,h1],[1,1,h3]]]\n            prism += prism_1\n            \n            series_1, triang_1, power_1 = Hilb(prism_1)\n            series += series_1\n            triang.append(triang_1)\n            power.append(power_1)\n                \n            for h in range(h2,h1):\n                # h2 <= h < h1\n                prism_1 = [[[1,0,0],[0,0,h],[0,0,h+1],[0,1,h2]]]\n                prism += prism_1\n                \n                series_1, triang_1, power_1 = Hilb(prism_1)\n                series += series_1\n                triang.append(triang_1)\n                power.append(power_1)\n            return prism, series, triang, power\n                \n    else:\n        assert(h2 == h3)\n        assert(h1 > h2)\n        # h1 > h2 = h3\n        prism = []\n        series = 0\n        for h in range(h2):\n            # 0 <= h < h2\n            prism_1 = [[[1,0,0],[0,0,h],[0,0,h+1],[1,1,h3]]]\n            prism_2 = [[[0,1,h2],[0,0,h],[0,0,h+1],[1,1,h3]]]\n            prism += prism_1 + prism_2\n\n            series_1, triang_1, power_1 = Hilb(prism_1)\n            series_2, triang_2, power_2 = Hilb(prism_2)\n            series += series_1 + series_2\n            triang.append(triang_1)\n            triang.append(triang_2)\n            power.append(power_1)\n            power.append(power_2)\n        \n        for h in range(h2,h1):\n            # h2 <= h < h1\n            prism_1 = [[[1,0,0],[0,0,h],[0,0,h+1],[1,1,h3]]]\n            prism_2 = [[[0,1,h2],[0,0,h],[0,0,h+1],[1,1,h3]]]\n            prism += prism_1 + prism_2\n\n            series_1, triang_1, power_1 = Hilb(prism_1)\n            series_2, triang_2, power_2 = Hilb(prism_2)\n            series += series_1 + series_2\n            triang.append(triang_1)\n            triang.append(triang_2)\n            power.append(power_1)\n            power.append(power_2)\n        \n    return prism, series, triang, power\n\nprint('Okay.')","state":"done","pos":2,"cell_type":"code","type":"cell","end":1546883512969,"id":"dc3800","kernel":"sagemath"}
{"output":{"0":{"text":"Okay.\n","name":"stdout"}},"exec_count":4,"start":1546883521985,"input":"# numerical solver\nimport scipy.optimize\nimport csv\nfrom scipy.optimize import fsolve\n\ndef func(p, *d):\n    f1, f2, f3 = d\n    return (f1(b1 = p[0], b2 = p[1], b3 = p[2]), f2(b1 = p[0], b2 = p[1], b3 = p[2]), f3(b1 = p[0], b2 = p[1], b3 = p[2]))\n\ndef constraint(Series, sol, vol_min_global):\n    vol = Series(b1 = sol[0], b2 = sol[1], b3 = sol[2])\n    vol = abs(vol)\n    if vol <= 1 and vol >= vol_min_global:\n        return 1, vol\n    \n    print 'volume: ', vol, ' is out of bounds.'\n    \n    return 0, -1\n    \ndef NSolve(Series, d, vol_min_global, bound=[[0,1],[0,1],[0,1]], MAX_COUNT=3):\n    vol = -1\n    sol = -1\n    const = 0\n    count = 0\n    \n    b1_min = bound[0][0]\n    b1_max = bound[0][1]\n    b2_min = bound[1][0]\n    b2_max = bound[1][1]\n    b3_min = bound[2][0]\n    b3_max = bound[2][1]\n\n    while const == 0:\n        if count >= MAX_COUNT:\n            return vol,sol\n            \n        count += 1\n        d1_0 = np.random.uniform(low=b1_min, high=b1_max)\n        d2_0 = np.random.uniform(low=b2_min, high=b2_max)\n        d3_0 = np.random.uniform(low=b3_min, high=b3_max)\n        print 'reset starting point: ', d1_0, d2_0, d3_0\n\n        try:\n            sol = fsolve(func, x0 = np.array([d1_0, d2_0, d3_0]), args = d)\n            print 'solution: ', sol\n            print 'guessed vol: ', Series(b1 = sol[0], b2 = sol[1], b3 = sol[2])\n        except:\n            continue\n        \n        const, vol = constraint(Series, sol, vol_min_global)\n\n    print 'Done.'\n\n    return vol, sol\n\ndef solver(series, b_max, h_max, sol_max=100):\n    # find derivative\n    d1 = diff(series, b1)\n    d2 = diff(series, b2)\n    d3 = diff(series, b3)\n    d = (d1, d2, d3)\n    # find the volume lower bound\n    vol_min_global = 1/h_max**3\n    # divide solution space into grids\n    x_max, y_max, z_max = b_max\n    x = np.linspace(0, x_max, x_max+1)\n    y = np.linspace(0, y_max, y_max+1)\n    z = np.linspace(0, z_max, z_max+1)\n    xv, yv, zv = np.meshgrid(x, y, z)\n    for i in range(x_max):\n        for j in range(y_max):\n            for k in range(z_max):\n                # find the bounds\n                b1_min = xv[i,j,k]\n                b1_max = b1_min+1\n                b2_min = yv[i,j,k]\n                b2_max = b2_min+1\n                b3_min = zv[i,j,k]\n                b3_max = b3_min+1\n                bounds = [[b1_min, b1_max],[b2_min,b2_max],[b3_min,b3_max]]\n                # try solve\n                vol, sol = NSolve(series, d, vol_min_global, bounds)\n                if type(sol) == int or type(vol) == int:\n                    # sol = -1 and vol = -1\n                    print ('range ', b1_min,b2_min,b3_min,' does not work')\n                    continue\n                if type(sol) == np.ndarray:\n                    # edge case\n                    sol = sol.tolist()\n                if sol[0] > sol_max or sol[1] > sol_max or sol[2] > sol_max:\n                    print ('solution out of bounds.')\n                    continue\n                if vol_min_global < vol < 1:\n                    print ('vol:', vol, '; sol:', sol)\n                    return vol, sol\n    print('cannot find solution.')\n    return -1,-1\n\ndef generate_vol(h_max, coeff=2):\n    # Input:\n    #   h_max: the max height of the polytope\n    #   coeff: an empirical factor that determines the search space\n    # Output:\n    # triang_list: data for each polytope of height [h1,h2,h3]\n    #   [h1,h2,h3]: heights\n    #   vol: minimum volume\n    #   sol: solution (i.e. the b's in the hilber series)\n    #   prism: polytope point set\n    #   series: hilbert series\n    #   triang: triangulation of the polytope\n    #   power: order of the t's in the hilbert series\n    triang_list = []\n    for h1 in range(1,h_max):\n        for h2 in range(h1+1):\n            for h3 in range(h2+1):\n                print(h1,h2,h3)\n                prism, series, triang, power = lift_prism(h1,h2,h3)\n                b_max = (h1*coeff,h1*coeff,h1*coeff)\n                vol, sol = solver(series, b_max, h1*coeff)\n                triang_list.append([[h1,h2,h3], vol, sol, prism, series, triang, power])\n                print('')\n    return triang_list\n    \nprint('Okay.')","state":"done","pos":4,"cell_type":"code","type":"cell","end":1546883523116,"id":"3f704c","kernel":"sagemath"}
{"output":{"0":{"text":"Okay\n","name":"stdout"}},"exec_count":1,"start":1546883503543,"input":"import numpy as np\nimport scipy\nimport math\nimport os\nPointConfiguration.set_engine('internal')\nprint('Okay')","state":"done","pos":0,"cell_type":"code","type":"cell","end":1546883504016,"id":"31239b","kernel":"sagemath"}
{"output":{"0":{"text":"Okay\n","name":"stdout"}},"exec_count":2,"start":1546883507609,"input":"def exist(pts, latt):\n    latt = np.array(latt)\n    for i in range(pts.shape[0]):\n        if pts[i][0]==latt[0]:\n            if pts[i][1]==latt[1]:\n                if pts[i][2]==latt[2]:\n                    return 1\n    return 0\n\ndef contain(poly, latt):\n    if poly.contains(latt) == 1:\n        return 1\n    else:\n        poly_latt = Polyhedron(vertices = [tuple(latt)])\n        vert = next(poly_latt.vertex_generator())\n        face_eq = poly.Hrepresentation()\n        for eq in face_eq:\n            if eq.contains(vert) != 1:\n                return 0\n        return 1\n    return 0\n\ndef check_latt(p):\n    pts = np.array(p)\n    pts_max = int(max(np.amax(pts, axis=0)))+1\n    pts_min = int(min(np.amin(pts, axis=0)))-1\n    print ('pts_max and pts_min: ', pts_max, pts_min)\n    poly = Polyhedron(p)\n    pts_new = pts\n    for i in range(pts_min, pts_max):\n        for j in range(pts_min, pts_max):\n            for k in range(pts_min, pts_max):\n                latt = [i,j,k]\n                if exist(pts, latt) == 1:\n                    continue\n                if contain(poly, latt) == 1:\n                    pts_new = np.append(pts_new, np.array(latt).reshape((1,3)), axis = 0)  \n    pts_new = pts_new.tolist()\n    return pts_new\n\ndef four_cross(v1, v2, v3, v4):\n    #Compute cross product of three 4-vectors\n    #print (\"input vectors: \", v1, v2, v3, v4)\n    v = np.zeros((4,))\n    counter = 0\n    \n    for i in range(4):\n        mat = [v1[np.arange(len(v1))!=i].tolist(), v2[np.arange(len(v2))!=i].tolist(), v3[np.arange(len(v3))!=i].tolist()]\n        mat = matrix(ZZ, mat)\n        #print ('matrix: ')\n        #print (mat)\n        if counter == 1:\n            v[i] = -1*mat.det()\n            counter = 0\n            #print ('neg: ', v[i])\n            continue\n        elif counter == 0:\n            v[i] = mat.det()\n            counter = 1\n            #print ('pos: ', v[i])\n    #print v\n    mat = matrix(RR, [v1.tolist(), v2.tolist(), v3.tolist(), v4.tolist()])\n    \n    if mat.det() < 0:\n        #print ('original: ', v)\n        v = -1*v\n        #print('changed: ', v)\n    #print ('vector: ', v)\n    return v\n\ndef Hilb(triang_list):\n    triang = []\n    # Add 1 at the end of all verticies\n    for tetra in triang_list:\n        tetra_new = []\n        for vert in tetra:\n            vert_new = np.append(np.array(vert),1).tolist()\n            tetra_new.append(vert_new)\n        triang.append(tetra_new)\n    \n    triang = np.array(triang)\n    # Add 1 to the end of all vectors\n    power = np.zeros(shape = triang.shape)\n    Hilb = 0\n    t = var('t')\n    t1 = var('t1')\n    t2 = var('t2')\n    t3 = var('t3')\n    t4 = var('t4')\n    for tri in range(triang.shape[0]):\n        hilb = 1\n        t_prod = 1\n        for i in range(4):\n            #Multiplying by -1 is optional\n            power[tri][i] = -1*four_cross(triang[tri][i], triang[tri][np.remainder(i+1, 4)], triang[tri][np.remainder(i+2, 4)], triang[tri][np.remainder(i+3, 4)])\n            t_prod = t1^(int(power[tri][i][0]))*t2^(int(power[tri][i][1]))*t3^(int(power[tri][i][2]))*t4^int((power[tri][i][3]))\n            hilb *= (1-t_prod)^(-1)\n        #print ('Hilbert: ', hilb)\n        Hilb += hilb\n#     print ('Hilb: ', Hilb())\n    #print (Hilb(t1=t, t2=t, t3=t).series(t4, 3))\n    #print (\"p-q web: \", power )\n    \n    \n    m = var('m')\n    b1 = var('b1')\n    b2 = var('b2')\n    b3 = var('b3')\n    b4 = var('b4')\n    Hilb *= m^4\n    \n    #print ('Hilb: ', str(Hilb(t1 = (m*b1).exp(), t2 = (m*b2).exp(), t3 = (m*b3).exp(), t4 = (m*4).exp())).replace('e', 'E'))\n    Series = Hilb(t1 = (m*b1).exp(), t2 = (m*b2).exp(), t3 = (m*b3).exp(), t4 = (m*4).exp()).series(m==0, 1)\n    \n    Series = Series.truncate()\n    \n    return Series, triang, power\n\ndef idx_to_pts(triang, pts):\n    # Input a list of lists of indicies\n    # Output a list of lists of points\n    triang_new = []\n    for i in range(len(triang)):\n        triang_new.append([pts[j] for j in triang[i]])\n    return triang_new\n\nprint('Okay')","state":"done","pos":1,"cell_type":"code","type":"cell","end":1546883508139,"id":"bc71e1","kernel":"sagemath"}
{"type":"cell","id":"1b7935","pos":3,"input":"def prism_plot(prism):\n    count = 0\n    plot = 0\n    for p in prism:\n        poly = Polyhedron(vertices=p)\n        if count == 0:\n            count += 1\n            plot = poly.plot()\n        else:\n            plot += poly.plot()\n    \n#     print(poly_list.vertices())\n    return plot\n\nprism,series, triang, power = lift_prism(3,0,0)\nprint(prism)\nprism_plot(prism)","output":{"0":{"name":"stdout","output_type":"stream","text":"[[[1, 0, 0], [0, 0, 0], [0, 0, 1], [1, 1, 0]], [[0, 1, 0], [0, 0, 0], [0, 0, 1], [1, 1, 0]], [[1, 0, 0], [0, 0, 1], [0, 0, 2], [1, 1, 0]], [[0, 1, 0], [0, 0, 1], [0, 0, 2], [1, 1, 0]], [[1, 0, 0], [0, 0, 2], [0, 0, 3], [1, 1, 0]], [[0, 1, 0], [0, 0, 2], [0, 0, 3], [1, 1, 0]]]\n"},"1":{"data":{"iframe":"4395fed4d93e6ce442df84eea41628f1bf37c0a4"},"output_type":"execute_result","exec_count":13}},"cell_type":"code","exec_count":13}
{"type":"cell","id":"5072f1","pos":6,"input":"h1 = 2\nh2 = 1\nh3 = 0\nprint(h1,h2,h3)\nprism, series, triang, power = lift_prism(h1, h2, h3)\ntriang = np.squeeze(np.array(triang))\npower = np.squeeze(np.array(power))\nprint(series)\nprint(prism)\nprint(triang)\nprint(power)","output":{"0":{"name":"stdout","output_type":"stream","text":"(2, 1, 0)\n(0, 1, 2)\n1\n1/((2*b1 + b2 + b3 - 12)*(2*b1 + b3 - 8)*(b1 - b2)*b1) + 1/((b1 + b3 - 4)*b1*(b2 + b3 - 4)*(b2 - 4)) - 1/((3*b1 + b3 - 12)*(2*b1 + b3 - 8)*(b1 - b2)*b2) + 1/((b1 - b2)*b1*(b2 + b3 - 4)*b3) - 1/((b1 - b2)*(b1 + b3 - 4)*b2*b3)\n[[[1, 0, 0], [1, 1, 0], [0, 0, 0], [0, 0, 1]], [[0, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 1]], [[1, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 1]], [[1, 0, 0], [1, 1, 0], [0, 0, 2], [0, 0, 3]], [[1, 1, 0], [0, 1, 2], [0, 0, 2], [0, 0, 3]]]\n[[[1 0 0 1]\n  [1 1 0 1]\n  [0 0 0 1]\n  [0 0 1 1]]\n\n [[0 0 0 1]\n  [1 1 0 1]\n  [0 1 0 1]\n  [0 0 1 1]]\n\n [[1 1 0 1]\n  [0 1 0 1]\n  [0 1 1 1]\n  [0 0 1 1]]\n\n [[1 0 0 1]\n  [1 1 0 1]\n  [0 0 2 1]\n  [0 0 3 1]]\n\n [[1 1 0 1]\n  [0 1 2 1]\n  [0 0 2 1]\n  [0 0 3 1]]]\n[[[ 0.  0.  1.  0.]\n  [ 1. -1. -0. -0.]\n  [ 0.  1.  0.  0.]\n  [-1. -0. -1.  1.]]\n\n [[ 0.  0.  1.  0.]\n  [-0. -1. -1.  1.]\n  [ 1.  0.  0.  0.]\n  [-1.  1. -0. -0.]]\n\n [[-0. -1. -0.  1.]\n  [ 1.  0.  0.  0.]\n  [-1. -0. -1.  1.]\n  [ 0.  1.  1. -1.]]\n\n [[ 2.  0.  1. -2.]\n  [ 1. -1. -0. -0.]\n  [ 0.  1.  0.  0.]\n  [-3. -0. -1.  3.]]\n\n [[ 2.  0.  1. -2.]\n  [ 1. -0. -0. -0.]\n  [-1.  1.  0.  0.]\n  [-2. -1. -1.  3.]]]\n"}},"cell_type":"code","exec_count":22}
{"type":"cell","id":"83f7ca","pos":9,"input":"test_file = open('test_triang.npy', 'w')\ntest_file.close()\nfor i in range(1,10):\n    test_file = open('test_triang.npy', 'a')\n    a1 = np.zeros((i,2))\n    a2 = np.ones((2,i))\n    test_file.close()","output":{"0":{"ename":"NotImplementedError","evalue":"Multiple enlargeable (0-)dimensions are not supported.","output_type":"error","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mNotImplementedError\u001b[0m                       Traceback (most recent call last)","\u001b[0;32m<ipython-input-8-3af48218ce8b>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      6\u001b[0m \u001b[0matom\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtables\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mFloat64Atom\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      7\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 8\u001b[0;31m \u001b[0marray_c\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mf\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcreate_earray\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mroot\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'data'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0matom\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mInteger\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mROW_SIZE\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      9\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     10\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0midx\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mrange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mNUM_COLUMNS\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/sage/sage-8.4_1804/local/lib/python2.7/site-packages/tables/file.pyc\u001b[0m in \u001b[0;36mcreate_earray\u001b[0;34m(self, where, name, atom, shape, title, filters, expectedrows, chunkshape, byteorder, createparents, obj, track_times)\u001b[0m\n\u001b[1;32m   1391\u001b[0m                        \u001b[0mfilters\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mfilters\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mexpectedrows\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mexpectedrows\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1392\u001b[0m                        \u001b[0mchunkshape\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mchunkshape\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbyteorder\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mbyteorder\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1393\u001b[0;31m                        track_times=track_times)\n\u001b[0m\u001b[1;32m   1394\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1395\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mobj\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/sage/sage-8.4_1804/local/lib/python2.7/site-packages/tables/earray.pyc\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, parentnode, name, atom, shape, title, filters, expectedrows, chunkshape, byteorder, _log, track_times)\u001b[0m\n\u001b[1;32m    160\u001b[0m         super(EArray, self).__init__(parentnode, name, atom, shape, title,\n\u001b[1;32m    161\u001b[0m                                      \u001b[0mfilters\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mchunkshape\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbyteorder\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0m_log\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 162\u001b[0;31m                                      track_times)\n\u001b[0m\u001b[1;32m    163\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    164\u001b[0m     \u001b[0;31m# Public and private methods\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/sage/sage-8.4_1804/local/lib/python2.7/site-packages/tables/carray.pyc\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, parentnode, name, atom, shape, title, filters, chunkshape, byteorder, _log, track_times)\u001b[0m\n\u001b[1;32m    220\u001b[0m         \u001b[0;31m# The `Array` class is not abstract enough! :(\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    221\u001b[0m         super(Array, self).__init__(parentnode, name, new, filters,\n\u001b[0;32m--> 222\u001b[0;31m                                     byteorder, _log, track_times)\n\u001b[0m\u001b[1;32m    223\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    224\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m_g_create\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/sage/sage-8.4_1804/local/lib/python2.7/site-packages/tables/leaf.pyc\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, parentnode, name, new, filters, byteorder, _log, track_times)\u001b[0m\n\u001b[1;32m    288\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    289\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 290\u001b[0;31m         \u001b[0msuper\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mLeaf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__init__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mparentnode\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0m_log\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    291\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    292\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m__len__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/sage/sage-8.4_1804/local/lib/python2.7/site-packages/tables/node.pyc\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, parentnode, name, _log)\u001b[0m\n\u001b[1;32m    264\u001b[0m             \u001b[0;31m#   Create or open the node and get its object ID.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    265\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mnew\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 266\u001b[0;31m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_v_objectid\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_g_create\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    267\u001b[0m             \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    268\u001b[0m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_v_objectid\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_g_open\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/sage/sage-8.4_1804/local/lib/python2.7/site-packages/tables/earray.pyc\u001b[0m in \u001b[0;36m_g_create\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m    174\u001b[0m             \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    175\u001b[0m                 raise NotImplementedError(\n\u001b[0;32m--> 176\u001b[0;31m                     \u001b[0;34m\"Multiple enlargeable (0-)dimensions are not \"\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    177\u001b[0m                     \"supported.\")\n\u001b[1;32m    178\u001b[0m         \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mNotImplementedError\u001b[0m: Multiple enlargeable (0-)dimensions are not supported."]}},"cell_type":"code","exec_count":8}
{"type":"cell","id":"8f72ab","pos":8,"input":"series_file = open('series_2.txt', 'w')\ntriang_file = open('triang.txt', 'w')\npower_file = open('power.txt', 'w')\ntriang_file.close()\npower_file.close()\n\ntriang_list = []\npower_list = []\n\nfor data in data_x:\n    h1 = data[0]\n    h2 = data[1]\n    h3 = data[2]\n    prism, series, triang, power = lift_prism(h1, h2, h3)\n    triang = np.squeeze(np.array(triang))\n    power = np.squeeze(np.array(power))\n    triang_list.append(triang)\n    power_list.append(power)\n    series_file.write(\"%s\\n\"%(str(series)))\nseries_file.close()\n\ntriang_list = np.squeeze(np.array(triang_list))\npower_list = np.squeeze(np.array(power_list))\nnp.savetxt('triang.txt', triang_list, fmt='%d')\nnp.savetxt('power.txt', power_list, fmt='%d')","cell_type":"code","exec_count":41}
{"type":"cell","id":"d1d68f","pos":10,"input":"test_file = open('test_triang.npy', 'r')\nfsz = os.fstat(test_file.fileno()).st_size","output":{"0":{"ename":"IOError","evalue":"Failed to interpret file <open file 'test_triang.npy', mode 'r' at 0x7f8028466db0> as a pickle","output_type":"error","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mIOError\u001b[0m                                   Traceback (most recent call last)","\u001b[0;32m<ipython-input-6-0457f6c746ca>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0mtest_file\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mopen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'test_triang.npy'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'r'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0mfsz\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mos\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfstat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtest_file\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfileno\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mst_size\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 3\u001b[0;31m \u001b[0mout\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mload\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtest_file\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      4\u001b[0m \u001b[0;32mwhile\u001b[0m \u001b[0mtest_file\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtell\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m<\u001b[0m \u001b[0mfsz\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m     \u001b[0mout\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mvstack\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mout\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mload\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtest_file\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/sage/sage-8.4_1804/local/lib/python2.7/site-packages/numpy/lib/npyio.pyc\u001b[0m in \u001b[0;36mload\u001b[0;34m(file, mmap_mode, allow_pickle, fix_imports, encoding)\u001b[0m\n\u001b[1;32m    427\u001b[0m             \u001b[0;32mexcept\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    428\u001b[0m                 raise IOError(\n\u001b[0;32m--> 429\u001b[0;31m                     \"Failed to interpret file %s as a pickle\" % repr(file))\n\u001b[0m\u001b[1;32m    430\u001b[0m     \u001b[0;32mfinally\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    431\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mown_fid\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mIOError\u001b[0m: Failed to interpret file <open file 'test_triang.npy', mode 'r' at 0x7f8028466db0> as a pickle"]}},"cell_type":"code","exec_count":6}
{"type":"cell","id":"db8725","pos":7,"input":"data_file = open('lift_1_40.txt', 'r')\ndata_x = []\ndata_y = []\nfor line in data_file:\n  data = eval(line)\n  if data[1] > 0:\n    data_x.append(data[0])\n    data_y.append(1/data[1])\n    \nprint ('Number of data: ', len(data_x))","output":{"0":{"name":"stdout","output_type":"stream","text":"('Number of data: ', 9506)\n"}},"cell_type":"code","exec_count":25}
{"type":"file","last_load":1546883992858}
{"type":"settings","kernel":"sagemath","backend_state":"running","metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.15"}},"kernel_usage":{"cpu":0,"memory":199913472},"trust":true,"kernel_state":"idle"}