{"output":{"0":{"data":{"text/latex":"$$ \\begin{alignat*}{1}\\min\\quad & subexpression_{1}\\\\\n\\text{Subject to} \\quad & b_{1} - 10.0 \\leq 0\\\\\n & subexpression_{1} - 0.125 \\geq 0\\\\\n & subexpression_{1} - 1.0 \\leq 0\\\\\n & b_{i} \\geq 0 \\quad\\forall i \\in \\{1,2,3\\}\\\\\nsubexpression_{1} = \\quad &1.0 / ((b_{1} - b_{2}) * b_{1} * ((b_{2} + b_{3}) - 4.0) * b_{3}) - 1.0 / ((b_{1} - b_{2}) * ((b_{1} + b_{3}) - 4.0) * b_{2} * b_{3})\\\\\n\\end{alignat*}\n $$"},"exec_count":7}},"exec_count":7,"start":1546881247696,"input":"using JuMP\nusing Ipopt\n\nmod = Model(solver = IpoptSolver())\n\n# Parameters\nvol_min = 1.0/8\nsol_max = 10.0\nnum_iter = 10\n\n@variable(mod, b[1:3] >= 0.0)\n\n# Objective function\n@NLexpression(mod, series, 1/((b[1] - b[2])*b[1]*(b[2] + b[3] - 4)*b[3]) - 1/((b[1] - b[2])*(b[1] + b[3] - 4)*b[2]*b[3]))\n# series = 1/((b[1][1] - b[2][1])*b[1][1]*(b[2][1] + b[3][1] - 4)*b[3][1]) - 1/((b[1][1] - b[2][1])*(b[1][1] + b[3][1] - 4)*b[2][1]*b[3][1])\n\n@NLconstraint(mod, b[1:3][1] <= sol_max)\n@NLconstraint(mod, series >= vol_min)\n@NLconstraint(mod, series <= 1.0)\n@NLobjective(mod, Min, series)\n\nmod","state":"done","pos":12,"cell_type":"code","type":"cell","end":1546881248129,"id":"9bd0a1","kernel":"julia-1"}
{"output":{"0":{"data":{"text/plain":"v\"1.0.3\""},"exec_count":1}},"exec_count":1,"start":1546880683470,"input":"VERSION","state":"done","pos":2,"cell_type":"code","type":"cell","end":1546880686444,"id":"ab8bd6","kernel":"julia-1"}
{"output":{"0":{"name":"stdout","text":"Solving...\n"},"1":{"name":"stdout","text":"\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit http://projects.coin-or.org/Ipopt\n******************************************************************************\n\nThis is Ipopt version 3.12.10, running with linear solver mumps.\nNOTE: Other linear solvers might be more efficient (see Ipopt documentation).\n\nNumber of nonzeros in equality constraint Jacobian...:        0\nNumber of nonzeros in inequality constraint Jacobian.:        7\nNumber of nonzeros in Lagrangian Hessian.............:       18\n\nThe inequality constraints contain an invalid number\n\nNumber of Iterations....: 0\n\nNumber of objective function evaluations             = 0\nNumber of objective gradient evaluations             = 0\nNumber of equality constraint evaluations            = 0\nNumber of inequality constraint evaluations          = 1\nNumber of equality constraint Jacobian evaluations   = 0\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 0\nTotal CPU secs in IPOPT (w/o function evaluations)   =      0.180\nTotal CPU secs in NLP function evaluations           =      0.003\n\nEXIT: Invalid number in NLP function or derivative detected.\nSolver status: Error\n"},"2":{"name":"stderr","text":"┌ Warning: Ipopt finished with status Invalid_Number_Detected\n└ @ Ipopt /home/user/.julia/packages/Ipopt/OLtKb/src/MPB_wrapper.jl:178\n┌ Warning: Not solved to optimality, status: Error\n└ @ JuMP /ext/julia/julia/depot/packages/JuMP/PbnIJ/src/nlp.jl:1283\n"},"3":{"name":"stdout","text":"Max height: 0"},"4":{"name":"stderr","text":"┌ Warning: `getObjectiveValue` is deprecated, use `getobjectivevalue` instead.\n│   caller = top-level scope at In[8]:7\n└ @ Core In[8]:7\n"},"5":{"name":"stdout","text":".0\n"}},"exec_count":8,"start":1546881252128,"input":"# Solve for the control and state\nprintln(\"Solving...\")\nstatus = solve(mod)\n\n# Display results\nprintln(\"Solver status: \", status)\nprintln(\"Max height: \", getObjectiveValue(mod))","state":"done","pos":13,"cell_type":"code","type":"cell","end":1546881258231,"id":"1141d6","kernel":"julia-1"}
{"output":{"0":{"name":"stdout","text":"\u001b[32m\u001b[1m  Building\u001b[22m\u001b[39m "},"1":{"name":"stdout","text":"Ipopt → `~/.julia/packages/Ipopt/OLtKb/deps/build.log`\n"},"2":{"name":"stderr","text":"┌ Info: Precompiling Ipopt [b6b21f68-93f8-5de0-b562-5493be1d77c9]\n└ @ Base loading.jl:1192\n"}},"exec_count":4,"start":1546880821305,"input":"import Pkg\nPkg.build(\"Ipopt\")\nusing Ipopt","state":"done","pos":4,"cell_type":"code","type":"cell","end":1546880870510,"id":"2fca7f","kernel":"julia-1"}
{"type":"cell","id":"2745fd","pos":3,"input":"Vectors and matrices have a simple syntax. Notice, that the `'` means to transpose this vector.","cell_type":"markdown"}
{"type":"cell","id":"53a7be","pos":5,"input":"A = [  1   9   1\n       0   1   0\n    -1.1   0  -1]","output":{"0":{"data":{"text/plain":"3×3 Array{Float64,2}:\n  1.0  9.0   1.0\n  0.0  1.0   0.0\n -1.1  0.0  -1.0"},"output_type":"execute_result","exec_count":4}},"cell_type":"code","exec_count":4}
{"type":"cell","id":"676ba6","pos":8,"input":"A * x","output":{"0":{"data":{"text/plain":"3×1 Array{Float64,2}:\n  1.0\n  4.4\n -9.0"},"output_type":"execute_result","exec_count":5}},"cell_type":"code","exec_count":5}
{"type":"cell","id":"76d550","pos":1,"input":"Evaluate the following cell by selecting it and then hit Shift+Return. Watch the top right status indicator of the Jupyter Notebook kernel to have started up Julia. The result will appear below.","cell_type":"markdown"}
{"type":"cell","id":"9178df","pos":9,"input":"## Batman Curve\n\nTranscribed from _Julia: A Fast Language for Numerical Computing_,\nby Alan Edelman,  \n[SIAM News, Volume 49 | Number 02 | March 2016](https://sinews.siam.org/Details-Page/julia-a-fast-language-for-numerical-computing-1)\n\n![](batman-demo-300.png)","cell_type":"markdown"}
{"type":"cell","id":"982fa9","pos":6,"input":"… and here we solve this as a linear system of equations: $A \\cdot x = b$","cell_type":"markdown"}
{"type":"cell","id":"9863f1","pos":10,"input":"# Note: the first time in a project, it can take over a minute to precompile PyPlot\nusing PyPlot\nfunction batman()\n\n    # bat functions: semicircle, ellipse, shoulders, bottom, cowl\n    # harmless Compat.UTF8String warnings from julia kernel on first run\n    σ(x) = sqrt.(1-x.^2)\n    e(x) = 3σ(x/7)\n    s(x) = 4.2 - .5x - 2.8σ(.5x-.5)\n    b(x) = σ(abs.(2-x)-1)-x.^2/11 + .5x - 3\n    c(x) = [1.7, 1.7, 2.6, .9]\n\n    # plot symmetrically across y-axis\n    p(x,f) = plot(-x,f(x), color=\"black\") , plot(x,f(x), color=\"black\")\n    p((3:.1:7),e);p(4:.1:7,t->-e(t))   # ellipse\n    p(1:.1:3,s);p(0:.1:4,b)            # shoulders and bottom\n    p([0,.5,.8,1],c)\nend\nbatman();","cell_type":"code","exec_count":0}
{"type":"cell","id":"9f5c69","pos":0,"input":"# Julia – a modern approach to scientific computing\n\n![](julia-logo-325-by-225.png)\n\nhttps://www.julialang.org\n\n","cell_type":"markdown"}
{"type":"cell","id":"f7dec7","pos":7,"input":"x = A \\ b","output":{"0":{"data":{"text/plain":"3×1 Array{Float64,2}:\n  476.0\n    4.4\n -514.6"},"output_type":"execute_result","exec_count":4}},"cell_type":"code","exec_count":4}
{"type":"cell","input":"","id":"e5e660","pos":11,"cell_type":"raw"}
{"type":"file","last_load":1546880371412}
{"type":"settings","kernel":"julia-1","backend_state":"running","metadata":{"language_info":{"file_extension":".jl","mimetype":"application/julia","name":"julia","version":"1.0.3"}},"trust":true,"kernel_usage":{"cpu":0.19960079840282258,"memory":386768896},"kernel_state":"idle"}