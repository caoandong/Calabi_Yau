
# This file was *autogenerated* from the file hilbert.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4)
import math
import numpy as np
import scipy
#import matplotlib.pyplot as plt
import csv

PointConfiguration.set_engine('internal')

def exist(pts, latt):
    latt = np.array(latt)
    for i in range(pts.shape[_sage_const_0 ]):
        if pts[i][_sage_const_0 ]==latt[_sage_const_0 ]:
            if pts[i][_sage_const_1 ]==latt[_sage_const_1 ]:
                if pts[i][_sage_const_2 ]==latt[_sage_const_2 ]:
                    return _sage_const_1 
    return _sage_const_0 

#Compute cross product of three 4-vectors
def four_cross(v1, v2, v3, v4):
    v = np.zeros((_sage_const_4 ,))
    counter = _sage_const_0 
    #print 'input vector: ', v1, v2, v3
    for i in range(_sage_const_4 ):
        mat = [v1[np.arange(len(v1))!=i].tolist(), v2[np.arange(len(v2))!=i].tolist(), v3[np.arange(len(v3))!=i].tolist()]
        mat = matrix(ZZ, mat)
        #print 'matrix: '
        #print mat
        if counter == _sage_const_1 :
            v[i] = -_sage_const_1 *mat.det()
            counter = _sage_const_0 
            #print 'neg: ', v[i]
            continue
        elif counter == _sage_const_0 :
            v[i] = mat.det()
            counter = _sage_const_1 
            #print 'pos: ', v[i]
    #print v
    mat = matrix(RR, [v1.tolist(), v2.tolist(), v3.tolist(), v4.tolist()])
    
    if mat.det() < _sage_const_0 :
        #print 'original: ', v
        v = -_sage_const_1 *v
        #print 'changed: ', v
    #print 'vector: ', v
    return v


def Hilb(tri, p, output):
    num_tri = len(tri)
    len_tri = len(tri[_sage_const_0 ])
    triang_list = np.zeros((num_tri, len_tri, _sage_const_4 ))
    #Convert each element of p into a 4-vector
    #whose last entry equals to 1
    for i in range(num_tri):
        for j in range(len_tri):
            triang_list[i][j] = np.append(np.array(p[tri[i][j]]) , _sage_const_1 )
            
    #print 'triang_list: '
    #print triang_list
    triang = np.array(triang_list)
    power = np.zeros(shape = triang.shape)
    Hilb = _sage_const_0 
    t = var('t')
    t1 = var('t1')
    t2 = var('t2')
    t3 = var('t3')
    t4 = var('t4')
    for tri in range(triang.shape[_sage_const_0 ]):
        hilb = _sage_const_1 
        t_prod = _sage_const_1 
        for i in range(_sage_const_4 ):
            #Multiplying by -1 is optional
            power[tri][i] = -_sage_const_1 *four_cross(triang[tri][i], triang[tri][np.remainder(i+_sage_const_1 , _sage_const_4 )], triang[tri][np.remainder(i+_sage_const_2 , _sage_const_4 )], triang[tri][np.remainder(i+_sage_const_3 , _sage_const_4 )])
            t_prod = t1**(power[tri][i][_sage_const_0 ])*t2**(power[tri][i][_sage_const_1 ])*t3**(power[tri][i][_sage_const_2 ])*t4**(power[tri][i][_sage_const_3 ])
            hilb *= (_sage_const_1 -t_prod)**(-_sage_const_1 )
        #print 'Hilbert: ', hilb
        Hilb += hilb
    #print 'Hilb: ', Hilb(t1 = t, t2 = t, t3 = t, t4 = t^4).factor()
    #print Hilb(t1=t, t2=t, t3=t).series(t4, 3)
    output.write("p-q web: %s\n" % power)
    
    m = var('m')
    b1 = var('b1')
    b2 = var('b2')
    b3 = var('b3')
    b4 = var('b4')
    Hilb *= m**_sage_const_4 
    
    Series = Hilb(t1 = (m*b1).exp(), t2 = (m*b2).exp(), t3 = (m*b3).exp(), t4 = (m*_sage_const_4 ).exp()).series(m==_sage_const_0 , _sage_const_1 )
    Series = Series.truncate()
    d1 = diff(Series, b1)
    d2 = diff(Series, b2)
    d3 = diff(Series, b3)
    
    solution = solve([d1 == _sage_const_0 , d2 == _sage_const_0 , d3 == _sage_const_0 ], b1, b2, b3)
    
    sol_len = len(solution)
    
    vol_min_abs = Series(b1 = solution[_sage_const_0 ][_sage_const_0 ].rhs(), b2 = solution[_sage_const_0 ][_sage_const_1 ].rhs(), b3 = solution[_sage_const_0 ][_sage_const_2 ].rhs())
    
    if sol_len > _sage_const_1 :
        #print 'sol_len: ', sol_len
        for i in range(_sage_const_1 , sol_len):
            vol_min = Series(b1 = solution[i][_sage_const_0 ].rhs(), b2 = solution[i][_sage_const_1 ].rhs(), b3 = solution[i][_sage_const_2 ].rhs())
            if vol_min < vol_min_abs and vol_min > _sage_const_0 :
                vol_min_abs = vol_min
    
    return vol_min_abs
    
def Triang(p, output):
    pts = np.array(p)
    poly = Polyhedron(p)
    pts_max = int(max(np.amax(pts, axis=_sage_const_0 )))
    pts_new = pts
    for i in range(_sage_const_0 , pts_max):
        for j in range(_sage_const_0 , pts_max):
            for k in range(_sage_const_0 , pts_max):
                latt = [i,j,k]
                if exist(pts, latt)==_sage_const_1 :
                    continue
                if poly.contains(latt) == _sage_const_1 :
                    pts_new = np.append(pts_new, np.array(latt).reshape((_sage_const_1 ,_sage_const_3 )), axis = _sage_const_0 )  
    #print 'pts_new: ', pts_new
    pts_new = pts_new.tolist()
    points = PointConfiguration(pts_new)
    triang = points.triangulate()
    triang = list(triang)
    #print 'triangulate: ', triang
    
    #Calculate the Hilbert series
    vol_min = Hilb(triang, pts_new, output)
    output.write("Vol: %s\n" % vol_min)
    #print 'vol_min: ', vol_min

input_path = 'input.csv'
output_path = 'output.txt'
with open(input_path) as f:
    pts = []
    pts_tmp = []
    
    for line in f:
        pt = line.split(' ')
        if line == '\n' or pt == '\n':
            pts.append(pts_tmp)
            pts_tmp = []
            continue
        for i in range(len(pt)):
            pt[i] = float(pt[i].strip(','))
        pts_tmp.append(pt)
    if line != '\n':
        pts.append(pts_tmp)
        
output = open(output_path, 'w')

for idx in range(len(pts)):
    output.write("polytope %s\n" % idx)
    Triang(pts[idx], output)
    output.write("\n")

output.close()

